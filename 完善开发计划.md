# 投资管理系统 - 完善开发计划

## 核心设计原则

* **个人使用**：单用户无需身份认证
* **轻量级**：最小依赖，快速启动
* **Vercel部署**：充分利用serverless特性
* **易开发维护**：代码结构简单清晰
* **学习成本低**：采用主流技术栈

## 技术架构调整

### 数据库方案：SQLite + Better-SQLite3

```
优势：
✅ 文件数据库，零配置
✅ Better-SQLite3 同步操作，代码简单
✅ Vercel Edge Runtime 支持
✅ 个人使用性能充足
✅ 数据文件可直接备份

注意事项：
⚠️ Vercel 无状态环境，需考虑数据持久化
💡 建议：使用 Vercel KV 或定期备份到GitHub
```

### 技术栈

* **前端**: Next.js 14 (App Router)
* **数据库**: SQLite + Better-SQLite3
* **UI**: TailwindCSS + shadcn/ui
* **图表**: Recharts
* **部署**: Vercel

## 数据结构

```sql
-- 项目表
CREATE TABLE projects (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  项目名称 TEXT NOT NULL,
  项目代号 TEXT,
  交易类型 TEXT CHECK(状态 IN ('做多', '做空')),
  成本价 REAL,
  当前价 REAL,
  股数 INTEGER,
  仓位 REAL,
  成本金额 REAL,
  当前金额 REAL,
  盈亏金额 REAL,
  项目盈亏率 REAL,
  自主盈亏率 REAL,
  创建时间 DATETIME DEFAULT CURRENT_TIMESTAMP,
  完成时间 DATETIME
);

-- 交易表
CREATE TABLE transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  项目ID INTEGER,
  项目名称 TEXT,
  状态 TEXT CHECK(状态 IN ('计划', '完成')),
  交易名称 TEXT,
  交易类型 TEXT CHECK(状态 IN ('做多', '做空', '多头平仓', '空头平仓')),
  警告方向 TEXT CHECK(状态 IN ('向上', '向下')),
  距离 REAL,
  交易价 REAL,
  止盈价 REAL,
  止损价 REAL,
  股数 INTEGER,
  仓位 REAL,
  交易金额 REAL,
  最大亏损额 REAL,
  最大亏损率 REAL,
  最大盈利额 REAL,
  最大盈利率 REAL,
  创建时间 DATETIME DEFAULT CURRENT_TIMESTAMP,
  交易时间 DATETIME,
  FOREIGN KEY (项目ID) REFERENCES projects(id)
);

-- 基金表
CREATE TABLE funds (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  基金名称 TEXT NOT NULL,
  成本金额 REAL,
  当前金额 REAL
);

-- 基金净值记录
CREATE TABLE fund_nav_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  基金ID INTEGER,
  时间 DATETIME,
  累计净值 REAL,
  FOREIGN KEY (基金ID) REFERENCES funds(id)
);

-- 基金交易记录
CREATE TABLE fund_transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  基金ID INTEGER,
  交易类型 TEXT,
  交易净值 REAL,
  交易金额 REAL,
  交易时间 DATETIME,
  FOREIGN KEY (基金ID) REFERENCES funds(id)
);

-- 统计表
CREATE TABLE statistics (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  年月 TEXT,
  类型 TEXT,
  自主盈亏金额 REAL,
  自主盈亏率 REAL,
  基金盈亏金额 REAL,
  基金盈亏率 REAL,
  总盈亏金额 REAL,
  总盈亏率 REAL
);

-- 总览表
CREATE TABLE overview (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  自主总金额 REAL,
  自主成本金额 REAL,
  自主持仓金额 REAL,
  自主盈亏金额 REAL,
  自主盈亏率 REAL,
  自主仓位 REAL,
  基金总金额 REAL,
  基金盈亏金额 REAL,
  基金盈亏率 REAL,
  总投资金额 REAL,
  总盈亏金额 REAL,
  总盈亏率 REAL,
  更新时间 DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

## 项目结构

```
/invest-manager
├── app/
│   ├── api/
│   │   ├── projects/
│   │   ├── transactions/
│   │   ├── funds/
│   │   ├── statistics/
│   │   └── overview/
│   ├── dashboard/
│   ├── projects/
│   ├── transactions/
│   ├── funds/
│   └── statistics/
├── lib/
│   ├── db.ts              # SQLite 连接和初始化
│   ├── schema.sql         # 数据库Schema
│   └── utils.ts           # 工具函数
├── components/
│   ├── ui/                # shadcn/ui 组件
│   ├── charts/            # 图表组件
│   └── forms/             # 表单组件
└── data/
    └── investment.db      # SQLite 数据库文件
```

## 数据计算逻辑

### 项目 (projects)

**前端输入字段**：

* 项目名称
* 项目代号
* 交易类型（做多/做空）
* 当前价
* 创建时间
* 完成时间

**系统计算字段**：

* **成本价** = 成本金额 ÷ 股数 （股数 > 0 时）
* **股数** = ∑(交易股数)

  * 做多、空头平仓：股数加
  * 做空、多头平仓：股数减
* **仓位** = (当前金额 ÷ 自主总金额) × 100 （自主总金额 > 0 时）
* **成本金额** = ∑(交易金额)

  * 做多、空头平仓：金额加
  * 做空、多头平仓：金额减
* **当前金额** = 股数 × 当前价
* **盈亏金额** = 当前金额 - 成本金额
* **项目盈亏率** = (盈亏金额 ÷ 成本金额) × 100 （成本金额 > 0 时）
* **自主盈亏率** = (盈亏金额 ÷ 自主总金额) × 100 （自主总金额 > 0 时）

### 交易 (transactions)

**前端输入字段**：

* 交易名称
* 状态（计划/完成）
* 交易类型
* 警告方向（向上/向下）
* 交易价
* 止盈价
* 止损价
* 股数
* 仓位
* 交易金额
* 创建时间
* 交易时间

**系统计算字段**：

* **距离**：

  * 若方向 = 向下： - (交易价 - 项目当前价) ÷ 项目当前价 × 100
  * 若方向 = 向上：   (交易价 - 项目当前价) ÷ 项目当前价 × 100
* **最大亏损额** = (止损价 - 交易价) × 股数
* **最大亏损率** = (最大亏损额 ÷ 自主总金额) × 100 （自主总金额 > 0 时）
* **最大盈利额** = (止盈价 - 交易价) × 股数
* **最大盈利率** = (最大盈利额 ÷ 自主总金额) × 100 （自主总金额 > 0 时）

## 开发阶段

### 阶段1: 基础框架 (1-2天)

1. 创建 Next.js 项目
2. 配置 TailwindCSS + shadcn/ui
3. 设置 SQLite + Better-SQLite3
4. 创建数据库Schema和初始化脚本

### 阶段2: 核心API (2-3天)

1. 项目管理 API (CRUD)
2. 交易管理 API
3. 基金管理 API
4. 统计计算逻辑

### 阶段3: 前端页面 (3-4天)

1. Dashboard 总览页面
2. 项目管理页面
3. 交易管理页面
4. 基金管理页面
5. 统计分析页面

### 阶段4: 完善和部署 (1-2天)

1. 数据验证和错误处理
2. 响应式设计优化
3. Vercel 部署配置
4. 数据备份方案

## 关键技术点

### 1. SQLite 在 Vercel 的处理

```typescript
// lib/db.ts
import Database from 'better-sqlite3';
import path from 'path';

let db: Database.Database | null = null;

export function getDatabase() {
  if (!db) {
    const dbPath = path.join(process.cwd(), 'data', 'investment.db');
    db = new Database(dbPath);
    initializeDatabase(db);
  }
  return db;
}
```

### 2. 数据持久化策略

* 开发环境：本地SQLite文件
* 生产环境：考虑使用Vercel KV或定期备份机制

### 3. 计算逻辑封装

```typescript
// lib/utils.ts
export function calculateProjectMetrics(project: Project) {
  const 当前金额 = project.当前价 * project.股数;
  const 盈亏金额 = 当前金额 - project.成本金额;
  const 项目盈亏率 = (盈亏金额 / project.成本金额) * 100;

  return {
    当前金额,
    盈亏金额,
    项目盈亏率
  };
}
```

## 部署注意事项

1. **环境变量**: 最小化配置，主要是数据库路径
2. **构建优化**: 确保SQLite文件正确打包
3. **Edge Runtime**: 利用Vercel Edge功能提升性能
4. **备份策略**: 定期导出数据到JSON或CSV

## 维护建议

1. **代码组织**: 按功能模块划分，单一职责
2. **类型安全**: 使用TypeScript严格模式
3. **错误处理**: API统一错误响应格式
4. **数据验证**: 使用Zod进行输入验证
5. **测试**: 重点测试计算逻辑正确性

## 学习成本评估

* **新手友好**: Next.js + SQLite 学习曲线平缓
* **文档丰富**: 所选技术栈文档完善
* **调试简单**: SQLite 可直接查看，便于调试
* **部署简单**: Vercel 一键部署
